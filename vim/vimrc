" Vim-Plug Plugin Manager

" install vim-plug if not already installed
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall | source $MYVIMRC
endif

call plug#begin('~/.vim/plugged')

" General plugins
Plug 'tpope/vim-sensible'
Plug 'ervandew/supertab'
Plug 'majutsushi/tagbar'
Plug 'sirver/ultisnips'
Plug 'honza/vim-snippets'
Plug 'bling/vim-airline'
Plug 'tpope/vim-dispatch'
Plug 'tpope/vim-fugitive'
Plug 'lambacck/vim-matchit'
Plug 'scrooloose/syntastic'
Plug 'bitc/vim-bad-whitespace'
Plug 'christoomey/vim-tmux-navigator'
Plug 'yegappan/greplace'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'

" Python plugins
Plug 'davidhalter/jedi-vim', { 'for': 'python' }
Plug 'vim-scripts/indentpython.vim', { 'for': 'python' }
Plug 'tmhedberg/SimpylFold', { 'for': 'python' }
Plug 'nvie/vim-flake8', { 'for': 'python' }
Plug 'ivanov/vim-ipython', { 'for': 'python' }

" Other language-specific plugins
Plug 'lervag/vimtex', { 'for': ['tex', 'rnoweb'] }
Plug 'Vim-R-plugin2', { 'for': ['R', 'rnoweb'] }
Plug 'derekwyatt/vim-scala', { 'for': 'scala' }

call plug#end()

" vim > vi
set nocompatible

" syntax highlighting and auto-indentation
syntax on
filetype indent on
filetype plugin on
set ai
set si

" use ; instead of :
nnoremap ; :

" use jk or kj to leave insert mode and return to normal mode
imap jk <ESC>
imap kj <ESC>
imap JK <ESC>
imap KJ <ESC>
imap Jk <ESC>
imap jK <ESC>
imap Kj <ESC>
imap kJ <ESC>

" faster tab navigation
nnoremap <S-tab> :tabprevious<CR>
nnoremap <tab> :tabnext<CR>

" searching options
set incsearch
set showcmd
set ignorecase
set smartcase

" disable backups
set nobackup
set nowritebackup
set noswapfile

" disable annoying beep on errors
set noerrorbells
if has('autocmd')
  autocmd GUIEnter * set vb t_vb=
endif

" keep at least 5 lines on either side of cursor
set scrolloff=5

" window options
set showmode
set showcmd
set ruler
set ttyfast
set backspace=indent,eol,start
set laststatus=2

" line numbers
set number
highlight LineNr ctermfg=gray ctermbg=black

" better tab completion on commands
set wildmenu
set wildmode=list:longest

" close buffer when tab is closed
set nohidden

" enable the mouse
set mouse=a

" set colorscheme
colorscheme slate
set background=dark

" function to check whether there is an open file in the current tab
function! TabIsEmpty()
    return winnr('$') == 1 && len(expand('%')) == 0 && line2byte(line('$') + 1) <= 2
endfunction

" shortcuts to common commands
let mapleader = ","
nnoremap <leader>e :FZF<CR>
nnoremap <leader>n :tabnew<CR>
nnoremap <expr> <leader>o TabIsEmpty() ? ":FZF<CR>" : ":tabnew<CR>:FZF<CR>"
nnoremap <leader>w :tabclose<CR>
nnoremap <leader>t :Tags<CR>
nnoremap <leader>s :vsplit<CR>
" nnoremap <leader>l :NERDTreeToggle<CR>

" trigger fold with space and open all folds by default
nnoremap <space> za
au BufRead * normal zR

" shortcut to close mini windows
nnoremap <leader>qq :cclose<CR>:pclose<CR>:lclose<CR>

" wrap and linebreak
set wrap
set linebreak

" default tab settings - expand tabs to 4 spaces
set shiftwidth=4
set tabstop=4
set smarttab
set expandtab

" always show tab line to avoid annoying resize
set showtabline=2

" make movements visual lines instead of actual lines
nnoremap j gj
nnoremap k gk
nnoremap 0 g0
nnoremap ^ g^
nnoremap $ g$
vnoremap 0 g0
vnoremap ^ g^
vnoremap $ g$

" Tagbar mapping
noremap <leader>tb :TagbarToggle<CR>

" Syntastic settings
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

" Set Ultisnips configs
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"

" Supertab configs
let g:SuperTabDefaultCompletionType = "context"
let g:SuperTabCompletionContexts = ['s:ContextText', 's:ContextDiscover']
let g:SuperTabContextTextOmniPrecedence = ['&omnifunc', '&completefunc']
let g:SuperTabContextDiscoverDiscovery =
            \ ["&completefunc:<c-p>", "&omnifunc:<c-x><c-o>"]

" Dispatch mappings
nnoremap <leader>dp :w<CR>:Make "%:r.pdf"<CR>
nnoremap <leader>dd :w<CR>:Make! "%:r.pdf"<CR>
nnoremap <leader>dv :w<CR>:Dispatch! open "%:r.pdf"<CR>
